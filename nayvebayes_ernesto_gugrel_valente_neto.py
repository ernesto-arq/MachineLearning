# -*- coding: utf-8 -*-
"""NayveBayes_Ernesto_Gugrel_Valente_neto.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gvs9Pk12zsotCBzXmPC7E_5Q2qp6_Q96
"""

# Ernesto Gurgel Valente Neto

"""# Agora é a sua vez! 

Qual a performance média que podemos esperar para esses classificadores no conjunto IRIS?

Escolha uma metodologia para avaliacao e 2 métricas (justifique sua resposta).
"""

from google.colab import drive
drive.mount('/content/drive')

"""#**Modelo/Algoritmo Bayesiano**
#**Métricas de Classificação: Acurácia**

"""

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KernelDensity
from sklearn.metrics import accuracy_score
import pandas as pd
import numpy as np

#Carregamento dos dados
data = pd.read_csv('iris.csv', header=(0))
classes = np.array(pd.unique(data[data.columns[-1]]), dtype=str)  

#conversao de vetor para vetor legivel pelo numpy
data = data.to_numpy()
nrow,ncol = data.shape
y = data[:,-1]
X = data[:,0:ncol-1]

# transformação dos dados
scaler = StandardScaler().fit(X)
X = scaler.transform(X)

# Dados de treinamento
# Dividindo 70% para treino e 30% para teste
p = 0.70
x_train, x_test, y_train, y_test = train_test_split(X, y, train_size = p, random_state = 42)

# Matriz que armazena as probabilidades
P = pd.DataFrame(data=np.zeros((x_test.shape[0], len(classes))), columns = classes) 
Pc = np.zeros(len(classes)) 
h = 2
for i in np.arange(0, len(classes)): 
    elements = tuple(np.where(y_train == classes[i]))
    Pc[i] = len(elements)/len(y_train) 
    Z = x_train[elements,:][0] 
    kde = KernelDensity(kernel='gaussian', bandwidth=h).fit(Z)
    for j in np.arange(0,x_test.shape[0]): 
        x = x_test[j,:]
        x = x.reshape((1,len(x)))
        pj = np.exp(kde.score_samples(x)) 
        P[classes[i]][j] = pj*Pc[i]
        
y_pred = []
for i in np.arange(0, x_test.shape[0]):
    c = np.argmax(np.array(P.iloc[[i]]))
    y_pred.append(classes[c])
y_pred = np.array(y_pred, dtype=str)

# calcula a acuracia
acuraria = accuracy_score(y_pred, y_test)
print('Acuracia:', acuraria)

"""Realizando uma pesquisa na web me deparei com a conseguinte informação " Classificador Bayesiano devido a que dado um dado, eu posso não saber à priori a classe, mas dado uma classe, eu talvez saiba à priori como são dos dados dessa classe". Desconhecendo o objetivo do data set iris e imaginando que seja algo como prever a variação de petalas, tamanho ou forma, dito isso o Classificador foi escolhido pela óptima da classe em relação os custos de cometer erros"""